# 概览

这个程序是程序设计判题中的一个步骤，也就是运行用户程序(已经编译好的程序)，获取用户运行的结果。

## 快速开始

先看几个例子吧。

- `./runner -l echo.log -u echo.out echo 123`  
  运行 `echo 123` 这个程序，中途生成的日志写到 `echo.log` 这个文件中，运行结果输出到 `echo.out` 这个文件中。 
  ![运行结果](https://i.loli.net/2021/03/14/tPcryONFHsfJWmi.png)
  ![日志文件](https://i.loli.net/2021/03/14/8kHslmaZJiywEB2.png)

- `./runner -l ls.log -u ls.out -- ls -al`  
  跟上一句的意思差不多，这次执行的是 `ls -al`。  
  这次的需要执行的命令带有一个前置 `-`，所以我们要把命令放在 `--` 后，
  这样 `-` 就不会被认为是 `runner` 的参数了。
  ![运行结果](https://i.loli.net/2021/03/19/8jBZuodeKMzaEbi.png)

## 解释

可以看到，这个程序就是执行你给出的运行命令，重定向你运行的命令的输入输出，并且输出了一个 JSON 字符串。

接下来我就要解释一下这都是什么东西。

首先是本文中会出现的一些名词：

| 名词     | 解释                           |
| -------- | ------------------------------ |
| runner   | 指本程序                       |
| 待判程序 | 指你让 runner 运行的那个命令。 |
| 判题数据 | 指要输入给待判程序的数据。     |

第一个例子是我们用 runner 执行 `echo 123`，`echo 1234` 在 Linux 系统中就是在终端输出 1234 的意思。

你会发现使用 runner 运行的程序默认的输入输出好像不见了，你没法输入数据，你预料中的数据也没有输出到终端中。这是因为 runner 默认重定向了待判程序的输入输出到了 `/dev/null` 这个文件这里，该文件是 Linux 系统中的黑洞，数据输入进去就消失了，从里面读取数据也只能读取到 EOF。

runner 可不只是这么简单的家伙，你可以通过一些参数来开启标准输入输出，或者指定给 runner 某个文件，然后 runner 会从该文件输入或者输出到该文件中。


### 结果

那么终端里的这个 JSON 格式的字符串是什么？我们可以把它当做这次运行程序的结果。让我们来看其中的一些字段：

![result](https://i.loli.net/2021/03/19/SMOzWy9fIF47kw6.png)


1. `exit_code`：
  待判程序的退出值。
2. `error_code`
  runner 内部检测到的本次运行出现的错误原因：
  ![error code](https://i.loli.net/2021/03/19/FCGcNsmTRk6zQte.png)
  `error_code` 为 1 的时候就是说你要运行的命令在环境变量 `PATH` 里找不到。

  全部 `error_code` 的值可见：[Code 一览 - error_code](/every-code/#error_code)

3. `status`
  这个值的意思就是你的程序运行是对是错了。比如说 0 就代表对了。对了的意思是程序执行的标准输出和你给的测试数据一样。

剩下的就是一些收集到的信息，运行时间，使用的内存等。
